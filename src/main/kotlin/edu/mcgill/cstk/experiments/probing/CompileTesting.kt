package edu.mcgill.cstk.experiments.probing

import ai.hypergraph.kaliningraph.parsing.*
import ai.hypergraph.kaliningraph.sampling.choose
import com.google.common.util.concurrent.AtomicLongMap
import edu.mcgill.cstk.disk.*
import edu.mcgill.cstk.utils.*
import java.io.*
import java.util.concurrent.atomic.LongAdder
import java.util.stream.Stream
import javax.tools.*
import kotlin.streams.asStream
import kotlin.time.*

//Scores [model=(valid, total)]:
//(microsoft/graphcodebert-base, 1267/1839)
//(dbernsohn/roberta-java, 433/1839)
//(huggingface/CodeBERTa-small-v1, 874/1839)
//(microsoft/codebert-base-mlm, 1377/1839)

fun main() {
  DATA_DIR.also { println("Evaluating $MODELS using javac on $it...") }
    .allFilesRecursively().allMethods().map { it.first }
    .filter { it.startsWith("public") && it.lines().size in 5..10 }
    .asStream().parallel()
    .filterValid(strict = true)
//    .flatMap { src -> src.constructPrompts().map { src to it }.distinct().take(3).asStream() }
    .evaluate(MODELS)
}

fun String.constructPrompts() =
  generateSequence { constructPrompt(this) }

private fun String.constructPrompt(
  mask: String = "[[MASK]]",
  maskChars: String = specialChars,
  escaped: String = Regex.escape(maskChars),
  split: List<String> = split(Regex("((?<=[$escaped])|(?=[$escaped]))")),
  toMask: Set<Int> = split.indices.filter { split[it] in maskChars }.toSet().choose(3).first(),
  maskedSeq: String = split.toMutableList().apply { toMask.forEach { this[it] = mask } }.joinToString("")
): String = if (!maskedSeq.isValidJava()) maskedSeq else constructPrompt()

fun Stream<String>.evaluate(
  models: Set<Model>,
  map: AtomicLongMap<Model> = AtomicLongMap.create(),
  total: LongAdder = LongAdder()
) =
  forEach { code ->
    models.forEach { model ->
      val prompt = code.constructPrompt(model.mask)
      val completion = model.fillEveryHole(prompt)
      val annotatedCompletion =
        if (completion.containsSyntaxError()) "$completion// Syntax error!"
        else { map.incrementAndGet(model); completion }
      if (prompt.lines().all { it.length < 50 })
        print(prettyDiffs(
          listOf(code, prompt, annotatedCompletion),
          listOf("code", "prompt", "completion")
        ))
    }

    total.increment()
    val summary = map.asMap().entries
      .map { (k, v) -> k to "$v/$total" }.joinToString("\n")
    println("\nScores [model=(valid, total)]:\n$summary")
  }

@OptIn(ExperimentalTime::class)
fun Stream<String>.filterValid(strict: Boolean = false, timed: Boolean = false): Stream<String> =
  if (!timed) filter { if (strict) !it.containsSyntaxError() else it.isValidJava() }
  else filter {
    val msJC = measureTimedValue { !it.containsSyntaxError() }.duration.inWholeMilliseconds
    measureTimedValue {
      it.also { println(it) }
      .isValidJava()
      .also { println("\tis ${if (it)"in" else ""}valid!") }
    }.also {
      val msSV = it.duration.inWholeMilliseconds
      val ratio = msJC.toDouble() / msSV.toDouble()
      println("SetValiant was ${String.format("%.3f",ratio).toDouble()} " +
        "times faster than the Java compiler! (SV: ${msSV}ms, JC: ${msJC}ms)")
    }.value
  }

// The language generated by this CFG over-approximates Java
val javaCFG = """
    START -> D T P
    P -> A | ( P ) | ( P ) | { P } | [ P ] | < P > | P P
    D -> public | static | void | D D
    A -> Îµ | w | . | ; | , | = | A A
    W -> w
    T -> W | W < T >
  """.parseCFG()

const val specialChars = "(){}<>[],=;" // .\":

// Much faster than Java compiler unless code snippet is very long
fun String.isValidJava() =
  javaCFG.isValid(
    splitByNonWordChars().filter { it.isNotBlank() }
      .joinToString(" ") { if (it in specialChars) it else "w" }
      // TODO: maybe we can apply this transformation automatically using the parser?
//      .also { println(" Original: $it") }
      .replace(Regex("w( w)*"), "w")
      .tokenizeByWhitespace()
//      .also { println("Distilled: $it") }
  )//.also { println("\tis ${if (!it) "in" else ""}valid Java!") }

// Slower but uses gold-standard Java parser
fun String.containsSyntaxError(): Boolean {
  val file = File.createTempFile("Test_${hashCode()}", ".java")
  file.writeText("class CompileTest { $this }")
  val errors = StringBuilder()
  object: OutputStream() { override fun write(b: Int) { errors.append(b.toChar()) } }
    .let { ToolProvider.getSystemJavaCompiler().run(null, null, it, file.path) }
  file.delete()

  return Regex("error: (.*)").findAll(errors.toString())
    .any { it.destructured.component1() != "cannot find symbol" }
}

//https://github.com/huggingface/transformers/pull/10222
/** TODO: Experiment idea
def fix_broken_code(code, lang_model):
    num_holes <- 1
    while [code] does not compile:
        sketchy_tokens <- calculate_highest_perplexity_tokens([num_holes], [code], [lang_model])
        code_template <- Replace or insert holes at [sketchy_tokens] in [code]
        llm_fixes <- Sample top-K insertions for each hole in [code_template] using [lang_model]
        admissible_set <- Solve [code_template] using SAT solver with [llm_fixes] as multi-choice
        if [admissible_set] is not empty:
            fixes <- rerank [admissible_set] with [lang_model] using maximum-likelihood criterion
            code <- Apply top fix in [fixes] to [code_template]
            return code
        num_holes <- num_holes + 1
 */